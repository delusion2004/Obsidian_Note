```
<view class="v1">
<image class="img1"></image>
```
</view>
1 为什么父容器v1也要设置成width: 100%; height: 100%;,才能显示图片，不应该子容器图片能把父容器撑开到width: 100%; height: 100%吗
在 Web 和小程序开发中，“子元素撑开父元素”是有前提条件的。
简单来说：如果子元素（图片）的宽高是百分比（%），它就无法撑开父元素，反而需要父元素先有明确的高度。
CSS 的计算逻辑是这样的：
图片说：我的宽度是父容器的 100%。
父容器（v1）说：我的宽度由子元素（图片）撑开。
结果：父容器在渲染初期发现自己没有内容，所以高度为 0；图片发现父容器高度为 0，于是 100% 算出来也是 0。
这就是为什么当你在 .img1 上写 height: 100% 时，如果 .v1 没写高度，图片就会彻底“消失”或高度为 0。

2
```
.t1{

  font-size: 40rpx;

  color: black;

  background-color: grey;

  position: absolute;

  left: 600rpx;

  top:50rpx;

  padding: 10rpx 20rpx;

  border-radius: 20rpx;

}
```
其中的padding起到了一个伪边框的作用，相当于把以text中的内容为中心，向上留出10rpx，像左留出20rpx的距离，同时因为设置的背影颜色是灰色因此显得像一个按钮一样

3 当需要app.json中window中配置的内容与单个页面冲突的时候，可以在xxx.json中进行修改，但是这个时候不需要再加window这个框架，直接在里面写就行了
![[Pasted image 20251231012131.png]]4 箭头函数和普通函数还是有一点的区别的
对于下面的一段代码，其中recordStart:function()我要是写成箭头函数的话是不能够正常使用的

```
原因:
普通函数（function)：它是“随遇而安”的。它没有固定的家，它的this指向谁调用它,谁就是它的家。当你写在Page({...})里并由小程序系统调用时，this 就会指向当前的这个页面对象。所以你能通过 this.setData 找到页面里的数据。
箭头函数（=>）：它是“从一而终”的。它在定义的那一刻，就会捕获当时周围环境的 this 作为自己的家。在小程序里，你定义Page({...})的时候，周围环境是整个 JS 文件（全局环境），此时的 this 通常是 undefined 或者全局对象 Window。
```

```
const recorderManager = wx.getRecorderManager()

var api = require("../../config/settings.js")

  

Page({

  

  /**

   * 页面的初始数据

   */

  data: {

    content:"",

    record:false

  },

  

  recordStart:function(){

    this.setData({record:true})

    const options = {

      // duration: 6000,//指定录音的时长，单位 ms

      sampleRate: 16000,//采样率

      numberOfChannels: 1,//录音通道数

      encodeBitRate: 48000,//编码码率

      format: 'wav'//音频格式，有效值

    }

    //开始录音

    recorderManager.start(options)

  },

  recordCancel:function(){

    console.log("停止");

    this.setData({record:false})

    wx.hideLoading()

  },

  recordStop:function(){

    if(!this.data.record){return}

    recorderManager.stop();

    recorderManager.onStop((res) => {

      // this.tempFilePath = res.tempFilePath

      wx.showLoading()

      wx.uploadFile({

        filePath: res.tempFilePath,

        name: 'voice',

        url: api.voice,

        success:(response)=>{

          console.log(response)

          // {'code': 100, 'msg':'成功','result': ['欢迎欢迎']}

          let voiceResponse = JSON.parse(response.data)

          if(voiceResponse.code == 100){

            console.log(voiceResponse)

              this.setData({

                content:this.data.content + voiceResponse.result[0]

              })

          }else{

            wx.showToast({

              title: '识别失败，请重新操作！',

              icon: "none"

            })

          }

        },

        complete:()=>{

          wx.hideLoading()

        }

      },

      )

    })

    this.setData({record:false})

  },

})
```

5 什么时候用箭头函数，什么时候用普通函数
	1 直接写在 Page({...}) 下面的、由按钮点击或生命周期触发的方法，必须用普通函数。
	2 在 wx.request、wx.uploadFile 或 setTimeout 的内部，建议用箭头函数。