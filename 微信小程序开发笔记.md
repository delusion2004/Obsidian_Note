# 1 基础知识
### 1.1 微信小程序默认不支持http，需要对其进行修改:设置->项目设置->本地设置->不校验.....
![[Pasted image 20251226094641.png]]
### 1.2 项目目录结构
##### 	1.2.1 项目主配置文件
	-app.js--小程序入口文件，小程序启动，会执行这个js(必须有)
	-app.json--小程序的全局配置：顶部的颜色，标题....，以及决定小程序的功能与结构（必须有）
> [!微信小程序的顶部]
![[Pasted image 20251226095503.png]]
	-app.wxss--小程序全局样式：所有样式全局生效，定义所有页面的全局外观，同css

##### 	1.2.2 页面文件
	-pages文件夹下面，有一个个的文件夹-->每一个文件夹下有4个文件
		-xx.js--页面逻辑，js代码控制(必须有)
		-xx.wxml--页面结构，布局，相当于html(必须有)
		-xx.json--页面配置，当前页面顶部颜色，标题.....
		-xx.wxss--页面的样式，如果全局样式也有的话，以当前页面为准
##### 	1.2.3 总体
![[Pasted image 20251226101439.png]]
![[Pasted image 20251226101747.png]]
### 1.3 项目配置
##### 	1.3.1 app.json--小程序全局配置文件，用于小程序的一些全局属性和页面路由，默认标题，顶部颜色，使用有下拉刷新......

	配置参考地址：
	https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html
##### 	1.3.2 部分全局配置说明
		pages--总共有多少页面
		entryPagePath--小程序默认页面
		window--全局的默认窗口表现，像顶部是否有颜色，是否有下拉
###### 	1.3.3 页面配置xx.json
		1 小程序页面配置文件，也称局部配置文件，用于配置当前页面的窗口样式，页面标题等
		2 页面配置会覆盖app.json中相同的配置项
###### 	1.3.4 工程配置
		1 即project.config.json和project.private.config.json文件
		2 小程序项目的配置文件，用于保存项目的一些配置信息和开发者的个人设置
		3 project.private.config.json文件中的配置会覆盖project.config,json中的相同字段
### 1.4 渲染和纯净项目
##### 1.4.1 webview和skyline渲染模式
		1 webview:老一点，支持老版本和新版本
		2 skyline:新一点。不支持老版本
		3 skyline调成webview模式(删除以下代码块)
```
  "renderer": "skyline",

  "rendererOptions": {

    "skyline": {

      "defaultDisplayBlock": true,

      "defaultContentBox": true,

      "tagNameStyleIsolation": "legacy",

      "disableABTest": true,

      "sdkVersionBegin": "3.0.0",

      "sdkVersionEnd": "15.255.255"

    }

  },

  "componentFramework": "glass-easel",
```
### 1.5 新建页面
##### 1.5.1 方法一
		1 在pages文件夹上右键点击新建文件夹
		2 在新建的文件夹上新建page(此处的page可以和文件夹的名字重名)、
		3 这样的话就会自动多出四个文件
			xx.js
			xx.wxml
			xx.json
			xx.wxss
		4 在app.json中的page中多一行
##### 1.5.2 方法二
		1 在app.json中page标签中进行添加
		2 按ctrl+s进行保存即可
### 1.6 设置启动页面
##### 1.6.1 方法一
		在app.json中的pages中修改顺序，第一个显示
##### 1.6.2 方法二
		通过entryPagePath配置
		"entryPagePath": "pages/index/index",
### 1.7 调试基础库
		因为微信小程序的版本一直在升级，而不同功能是在不同版本中添加的，也就是说有的新功能在老的版本库中没有，在开发时如果做的功能发现写了没有效果，可以确认一下这个基础库是否支持该功能，修改基础库是在设置->项目设置->本地设置中
		参考地址：
		https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/share-timeline.html
### 1.8 调试窗口
![[Pasted image 20251226134223.png]]
# 2 初步项目
### 2.1 window标签相关
`"navigationBarTitleText": "功能测试",//标题`

 `"navigationBarBackgroundColor": "#0000FF",//顶部颜色`

 `"enablePullDownRefresh": true,//是否带下拉刷新`

 `"backgroundColor": "#00FFFF",//下拉刷新的颜色`

 `"backgroundTextStyle":"light"//下拉刷新点点的颜色`
# 3 快速上手
### 3.1小程序常用组件
		1 text:不换行，放文字
![[Pasted image 20251226144810.png]]
		2 view:换行，相当于div，就是个容器可以嵌套其他的一些东西
![[Pasted image 20251226145009.png]]
		3 image:放图片
![[Pasted image 20251226145453.png]]
		4 icon：图标，不设置大小的话，默认大小
![[Pasted image 20251226145734.png]]	
### 3.2 tabbar配置
###### 3.2.1 解释
		tabbar相当于顶部或者底部的tab页，导航栏，几乎每一个小程序都会有这个
###### 3.2.2 配置
		在app.json中进行配置如下所示
```
	"tabBar": {

      "position": "bottom",

      "selectedColor": "#0000FF",

      "backgroundColor": "grey",

      "list": [{

        "pagePath": "pages/index/index",//相当于

        "text": "首页",
        //还可以添加
        //"iconPath":"images/home.png"，
        //"selectIconPath":"images/select_home.png"

      }, {

        "pagePath": "pages/login/login",

        "text": "登录"

      }]

    },
```
![[Pasted image 20251226150650.png]]	
# 4 小程序核心部分
### 4.1 尺寸
	1 因为每一个手机的尺寸不是一样的，故要是使用px像素会导致适配的问题，因此小程序进行了统一，整个的宽度就是750rpx，高度因为是下拉的可以一直往下拉，故，没有确切的最大高度，这样会导致无论在什么手机上都可以进行等比例缩放
	2 因此以后在设置高度，宽度的时候都统一用rpx
### 4.2 样式
##### 4.2.1 全局样式 app.wxss
		1 在这里面写css样式,整个小程序都会生效，在设置尺寸的时候注意要加rpx，否则可能不会生效
		//这个是类选择器，引用的话使用class="Myview"
			`.Myview{`

				  `height: 700rpx;`

				  `width: 200rpx;`

				  `background-color: blueviolet;`

				 `font-family: 200rpx;`

				`}`
##### 4.2.2 局部样式 xxx.wxss
		1 在这里面写css样式，只有当前页面生效
### 4.3 按钮
	1 在xxx.wxml中可以写，按钮是默认换行的。其中使用的是id选择器
plain表示按钮镂空
  `<button size="default">按钮1</button>`

  `<button size="mini" type="primary"  plain>按钮2</button>`

  `<button id="Mybutton" >按钮3</button>`
  //对于其中的plain他不需要写等于true,若是想为true则直接写plain，否则写成plain=false
  //在样式中还可以写background-color=red !import;表示优先以red这个颜色为准
 ![[Pasted image 20251226163038.png]]
	2 在wxss中，使用标签选择器
	`# Mybutton{`

	  `margin-top: 300rpx;/*表示距离顶部300rpx的距离 */`

	  `margin-bottom: 20rpx;`

	  `height: 180rpx;`

	  `width: 180rpx;`

	  `background-color: brown;`

	`}`
### 4.4 样式相关
![[Pasted image 20251226175715.png]]
### 4.5 引入矢量库
![[Pasted image 20251226215006.png]]
其中需要注意出现./static/font/font.wxss(1:22): unexpected end of input or bad input(env: Windows,mp,2.01.2510260; lib: 3.12.1)这样的报错现象需要开启下图才可以使用
![[Pasted image 20251226215055.png]]
### 4.6 Flex布局（详情见项目Demo2）
其中
justify-content: center; 决定内容在行里怎么摆放。想象一排文字，它是靠左、靠右还是居中。
align-items: center; 决定内容在高度上怎么摆放。想象一个容器很高，里面的元素是贴着顶部、底部还是在正中间。
![[Pasted image 20251228101750.png]]
### 4.7 事件绑定
	1 首先需要在标签中设置bind:tap属性，然后等于一个函数
![[Pasted image 20251228110225.png]]

	2 其次需要在xxx.js中的page({})中实现这个函数
![[Pasted image 20251228110404.png]]

	3 注意事项：
		 1 在小程序中没有alter()这个的使用，想要实现提示框的功能需要使用wx.showModel()
		 2 必须在page({})里面写函数
		 3 不论是否执行成功都会执行complete()中的内容，要是想要单独实现成功还是失败可以仿造complete函数来写success()和fail()
		4 bind:tap是点击事件，它还可以进行缩进成bindtap
### 4.8 事件冒泡
###### 4.8.1 事件冒泡解释
	事件冒泡是父组件上有事件，子组件上也有事件，一般情况下点击父组件只会运行父组件上的事件，但是如果要是点击子组件的话，会导致子组件和父组件上的事件一起触发
###### 4.8.1 阻止事件冒泡
	在事件的点击属性上把bind换成catch，既可以阻止事件冒泡
![[Pasted image 20251228113238.png]]
### 4.9 事件对象和传参
##### 4.9.1 解释
	当绑定了事件之后，函数都是可以接收到一个参数：事件对象(event)
##### 4.9.2 传参方式
		1 方法一
			使用data-键="值"
			不过使用这种方法当有事件冒泡的时候，他们里面的值是不一样的即
			currentTarget:事件绑定者
			target:事件触发者
			他们里面的值是不同的
		2 方法二
			使用mark:键="值"
			不受事件冒泡的影响
![[Pasted image 20251228120043.png]]
##### 4.9.3 输出方式
![[Pasted image 20251228120159.png]]
##### 4.9.4 注意
	因此注意使用不同的前缀来实现拿取对象
![[Pasted image 20251228120413.png]]
### 4.9页面跳转
##### 4.9.1 组件跳转（声明式导航）
	1 使用方式
		只需要在navigator标签中包裹着想要点击跳转的组件jike
![[Pasted image 20251228122548.png]]
	2 更多跳转方式（tabbar页面是指刚开始的时候，在app.json里面写tabbar中list里面的页面）
		1 navigate（默认）：保留当前页面，跳转到应用内的某个页面。但是不能跳到tabbar页面(因为它保留了当前页面，故跳转之后左上角会出现一个返回的小箭头)
		2 redirect: 关闭当前页面，跳转到应用内的某个页面。但不能跳转到tabbar页面(因为他是关闭当前页面，所以跳转之后只能点击返回首页)
		3 switchTab：跳转到tabbar页面，并关闭其他所有非tabbar页面
		4 reLaunch：关闭所有页面，打开到应用内的个页面
		5 navigateBack: 关闭当前页面，返回上一页面或多级页面(这个需要在跳转过去后的那个页面来写，其中还可以添加delta=“数字”，来表示回退几个页面)
		`<navigator open-type="navigateBack" delta="2"><button>回退</button></navigator>`
![[Pasted image 20251228124134.png]]
	3 携带以及获取参数
		携带：在url后面加上？name='xxx'&age='18'
![[Pasted image 20251228124331.png]]
		获取：在xxx.json的onLoad(options) {}里面获取，其中options就是传入的参数
![[Pasted image 20251228124625.png]]
##### 4.9.2 js跳转（编程式跳转）
	1 使用方式
		具体方式同组件跳转方式，唯一的不同就是写的方式不同，传参同组件跳转
![[Pasted image 20251228140827.png]]
![[Pasted image 20251228140838.png]]
	2 navigateBack(特殊）
![[Pasted image 20251228141316.png]]
### 5.0 wxml语法
##### 5.0.1 模板语法
	1 在页面的xx.js的page()方法的data对象中进行声明
	2 在xxx.wxml中使用{{}}来显示数据(和vue中的插值表示法是一样的)
	3 在{{}}中不能编写js语句或js方法,但是可以写以下内容
		-变量
		-算数运算
		-三元运算
		-逻辑判断
![[Pasted image 20251228144018.png]]
![[Pasted image 20251228144041.png]]
##### 5.0.2 改变数据(数字，对象，数组)（对于改变数据，想要渲染到图片上面必须要使用setData）
	1 改变数据
	这里面this是代指page里面的对象，注意是直接赋值
	注意这里面没有++的功能
	因为这是个对象，所以说不能用=，而是用:，来表示赋值，就像键值对
![[Pasted image 20251228183241.png]]
![[Pasted image 20251228183336.png]]
	2 改变对象属性和增加属性
		方法一：
![[Pasted image 20251228211354.png]]			
		方法二:
		因为是对象所以说改的话需要写成键值对的形式，所以要加''
![[Pasted image 20251228211528.png]]
		方法三：
![[Pasted image 20251228211850.png]]
	3 循环数组表示以及相关操作
		增加数组：
			1 方法一，采用push方法将值放入数组中
![[Pasted image 20251228213356.png]]
			2 方法二，使用concat方法对数组进行一个拼接，且拼接之后不能够使用方法一中的那种赋值方式，因为拼接之后会导致产生一个新的数组，因此需要设置一个变量来接受这个数组
![[Pasted image 20251228213709.png]]
			3 方法三，使用结构赋值的方法，注意这里的结构赋值和前面的解压赋值是不一样的，前面的是使用{}括起来的，而这个是使用[]括起来的，同时前面的那个因为是修改所以需要传入一对键值对，而现在这个只需要传入我想要添加的数组元素即可
![[Pasted image 20251228214045.png]]
		删除元素：
		slice(1)是切片，也就是说把原来的names[0]给删除了，故达到了删除的效果
![[Pasted image 20251228214320.png]]
		修改元素：
		直接调出对应的元素进行修改即可
		![[Pasted image 20251228214437.png]]
##### 5.0.3列表渲染
	1实现方式：
		但是这样写会导致出现一些警告
![[Pasted image 20251228214631.png]]

	下面是不出现警告的写法：，这种写法中wx:key="x"，其中的x只需要是一个唯一的值即可，无论写什么，经常有*this这种写法
![[Pasted image 20251228214733.png]]
	
	2相关事项：
		js const和let 和var区别
		    -老版本：定义变量用var，会有坑
		    -新版本：定义变量用 let，定义常量用const
	3解释：
		其中的item和index是只要遍历数组就会出现的两个值，其中item指的是其中的数组元素，index是数组下标，一般是不用改变的，但也有改变的方法(==谨记对象是键值对，需要冒号和单引号==)：
![[Pasted image 20251228220425.png]]

	4另一种方法：
	对于这种写法，运行之后，block相当于消失了，其中的元素全部都归那个大的view所有
![[Pasted image 20251228220658.png]]
##### 5.0.4 条件渲染
	1 wx:if,wx:elif,wx:else
![[Pasted image 20251228223239.png]]

	 2 wx:if和hidden的区别
		 1 使用wx:if
原：
![[Pasted image 20251228224236.png]]
点击后：
![[Pasted image 20251228224303.png]]
可以很明显的看出
`<image src="/images/8.webp" mode="aspectFit" wx:if="{{showPhoto}}"></image>`
这句话被删除了

		2使用hidden()
发现并没有进行删除
因此得到结论：wx:if会删除元素，hidden不会删除元素
### 5.1 flex布局
见[[flex布局-补充]]
.box>div与.box div是不同的
##### 	1..box > div（子代选择器）
中间的 > 符号表示直接子级。
规则：它只寻找紧跟在 .box 后面的那一层 div。
范围：只管“第一代”儿子（==**无论第一代有几个儿子都会管，而不是只管第一个div**==）。
例子：如果 div 嵌套在另一个 section 里面，它就管不着了。
##### 	2..box div（后代选择器）
中间的 空格 表示所有后代。
规则：只要这个 div 是在 .box 的内部，不论它嵌套了多少层。
范围：管“儿子”、“孙子”、“曾孙”……全家所有后代。
### 5.2 发送网络请求（相当于前后端交互）
##### 5.2.1 发送网络请求的域名，必须在微信公众平台配置
![[Pasted image 20251228225822.png]]

##### 5.2.2 发送请求
	-后端：写端口，返回信息等之类的
	-微信小程序端：发送请求获取数据，渲染到微信小程序上
##### 5.2.3实操：
注意事项：对于这个，我们需要保证收到的后端数据的标签名和前端的一致，可以先在控制台打印出res.data.data的值，看一下后端传来的数据的键是什么，然后再写前端的键，保证前后一样的键，防止不能够正确渲染
![[Pasted image 20251228233649.png]]
注意事项:
 1.对于这个的实现，我在使用this.setData渲染的时候，需要用res.data.data，这是因为我在后端封装了一个Result的返回结果，所以{code: 1, msg: null, data: Array(6)}，这个东西是res.data，而数据在这里面的data中，因此，想要正确的取出数据需要使用res.data.data才能够去除数据
 2.其中的mask是显示蒙层，也就是说如果mask是true的话，可以使得，在加载的过程中不能够点击后面的按钮，有效的防止了多次点击加载数据
 3.wx.showLoading不能够自动关闭，需要手动关闭
![[Pasted image 20251228234344.png]]
### 5.2 卖票网案例实现
见Demo3
### 5.3 对话框
#####  5.3.1 模态对话框
对于这个按钮，我传入了对应的电影名称，同时，使用弹出框的形式，来弹出，对于其中的内容绑定，我们可以发现，使用的是currentTarget，这是因为要是target是点击的那个组件，因为我点击的是购票，所以组件是text，因此会导致无法正常渲染弹出，而currentTarget是指绑定了点击事件的组件，所以这里应该使用currentTarget,同时住哟传参方式，event是固定的,dataset也是固定的。
![[Pasted image 20251229122735.png]]
![[Pasted image 20251229122716.png]]
![[Pasted image 20251229123615.png]]

##### 5.3.2 消息对话框
![[Pasted image 20251229124102.png]]
![[Pasted image 20251229124118.png]]


### 5.4 本地存储
##### 5.4.1 区别（同步与异步存储）
同步的意思是如果保存的很慢，会卡在那，异步相当于新开一个线程去干活，不会阻塞当前的操作
##### 5.4.2 同步存储
sync的意思是同步的意思
![[Pasted image 20251229144558.png]]
##### 5.4.3 异步存储
注意：在获取时得到的是一个对象，所以想要打印出和同步存储一样的结果需要，在后面加上.data来把数据拿出来，且异步是以一种json的格式输入数据，拿去数据的，这也是和前面不一样的地方
![[Pasted image 20251229145320.png]]

### 5.5 上滑加载更多
##### 5.5.1 核心部分
在json里面写这个东西，表示的是在距离底部还有100rpx的时候运行js里面生命周期的函数，即第二张图的函数，这个是通过拼接的方式，来实现增加
![[Pasted image 20251229153021.png]]
![[Pasted image 20251229153123.png]]

##### 5.5.2 其他
通过下面的设置方式，可以使得下拉刷新出来的view，奇数为粉色，偶数为青色，其中写的方式是固定的
![[Pasted image 20251229153230.png]]
### 5.6 下拉刷新
JSON中写这三个属性，其中第一个是开启下刷新，第二个设置下拉的背景颜色，第三个是指三个点点的颜色
![[Pasted image 20251229162518.png]]
对于这个js函数，page里面也是有的，因此不需要再单独创建，要是有两个的话，默认生效的是最后一个
![[Pasted image 20251229162631.png]]

疑问解答：为什么上面的那个NumList不需要加this.data，而下面的那个需要？
setData是微信小程序官方提供的一个函数（方法）。
它的设计逻辑是：你把想要更新的“键值对”传给它，它会自动帮你把这些东西合并到this.data中，并通知页面更新。
而下面的那个if 判断或 console.log 时，是在进行 “读取” 操作。
在 Page 的函数内部，如果只写NumList，程序会以为在找一个局部变量。如果不加this.data： 程序会在当前函数里找有没有var NumList 或let NumList。找不到就会报错NumList is not defined。
加上this.data：是在明确告诉程序：“请去当前页面对象（this）的属性仓库（data）里，把那个叫NumList 的值拿给我用。”
==简单记：改数据用setData({...})，拿数据用this.data.xxx==
### 5.7 scroll-view实现上拉下拉刷新模式

注意，这里有点小坑，必须要把整个页面充满的时候，往上滑增加列表元素才会生效，否则的话是不会生效的

scroll-view 的核心工作机制：只有当内容“溢出”并产生实际滚动，且滚动条到达底部时，才会触发触底事件。
这就是为什么刚开始我设置列表初始为三个元素没有生效，而之后我多设置了几个元素才得以生效：
	“触底”的前提是必须有“底”可触，如果你的元素很少（比如只有 1-3 个），它们的高度加起来还没有 scroll-view 容器本身的高度（100vh）高，那么所有内容一眼就能看全，是不需要滚动。
	既然没有滚动动作，或者滚动条根本不存在，系统就无法判断“什么时候是底部”。
	就会导致bindscrolltolower 监听不到滚动到边缘的动作，函数自然不会执行。
	
```
##### wxml####

<scroll-view

class="scroll"

scroll-y  # 运行y轴滑动

lower-threshold="100" # 距离底部还有100px时，触发事件

bindscrolltolower="handleGetData"# 事件处理函数

  
  

refresher-enabled="true"        # 开启 下拉刷新

refresher-default-style="black" # 下拉默认样式

refresher-background="#f0f0f0"  # 下拉背景色

bindrefresherrefresh="handleReload" # 下拉触发事件

refresher-triggered="{{isRefresh}}" # 设置下拉回弹，false允许回弹，

  

enable-back-to-top="true"  # 快速回到顶部，ios点顶部，安卓点tab

>

  <view wx:for="{{goods}}" wx:key="index">{{item}}</view>

</scroll-view>

  
  

### json###

{

  "usingComponents": {}

}

  

###wxss###

.scroll{

  /* 100vh就是指元素的高度等于当前浏览器的视窗高度,即浏览器内部的可视区域的高度大小 */

  height: 100vh;

  background-color: grey;

}

  

view{

  height: 400rpx;

  display: flex;

  justify-content: center;

  align-items: center;

}

/* 奇数 */

view:nth-child(odd){

  background-color: pink;

}

/* 偶数 */

view:nth-child(even){

  background-color: green;

}

#### js####

  data: {

    goods:[1,2,3,4],

    isRefresh:false

  },

  handleGetData(){

    console.log('上拉了')

    // 发送请求，加载数据

    wx.request({

      url: 'http://192.168.71.100:5000',

      method:'GET',

      success:(res)=>{

        console.log(res)

        this.setData({

          goods:this.data.goods.concat(res.data)

        })

      }

    })

  },

  handleReload(){

    console.log('下拉刷新了')

    wx.showToast({

      title: '下拉刷新',

    })

    this.setData({

      goods:[1,2,3,4]

    })

    this.setData({

      isRefresh:false

    })

  }
```

### 5.8 小程序强制更新
  原因：如果我们再微信端使用过小程序，那么微信会把小程序的代码拉到本地微信，这样会导致下次打开小程序的时候就会优先使用本地的代码，如果写的代码更新了，那么原来的代码中的一些接口之类的可能会被弃用，进而导致一些bug，因此使用强制更新使得每次更新之后，会强制更新到我们最先的代码
```
# 在 app.js 加入如下代码--》整个小程序第一次打开

onLaunch(){

    const update=wx.getUpdateManager()

    update.onUpdateReady(function(){

        wx.showModal({

            title: '发现新版本',

            content: '重启应用，更新版本新版本?',

            success:(res)=>{

                if(res.confirm){

                    update.applyUpdate()

                }

            }

        })

    })

}
```
### 5.9 生命周期
##### 5.9.1 整个应用的生命周期（app.js）
```
App({

  

  /**

   * 当小程序初始化完成时，会触发 onLaunch（全局只触发一次）

   */

  onLaunch: function () {

    console.log("小程序只要启动就会触发")

  },

  

  /**

   * 当小程序启动，或从后台进入前台显示，会触发 onShow

   */

  onShow: function (options) {

    console.log("小程序从后台切回，就会触发")

  },

  

  /**

   * 当小程序从前台进入后台，会触发 onHide

   */

  onHide: function () {

    console.log("小程序切入后台会触发")

  },

  

  /**

   * 当小程序发生脚本错误，或者 api 调用失败时，会触发 onError 并带上错误信息

   */

  onError: function (msg) {

  }

})
```

##### 5.9.2 某个页面的生命周期
下面的1，2，3是出现的顺序
```
 /**

   * 生命周期函数--监听页面加载

   */

  onLoad: function (options) {

    console.log('1 页面加载了')

    // 向后端发送请求

  },

  

  /**

   * 生命周期函数--监听页面初次渲染完成

   */

  onReady: function () {

    console.log('3 初次渲染完成')

  },

  

  /**

   * 生命周期函数--监听页面显示

   */

  onShow: function () {

    console.log('2 页面显示')

  },

  

  /**

   * 生命周期函数--监听页面隐藏

   */

  onHide: function () {
	//就是换到别的页面会触发
	
    console.log('4 页面隐藏')

  },

  

  /**

   * 生命周期函数--监听页面卸载

   */

  onUnload: function () {

    console.log('5 页面卸载')

  },
```

### 6.0 其他
##### 6.0.1 分享到朋友圈
首选，在实现这个功能时，必须要保证要先实现可以分享给朋友的代码，这是微信小程序规定的，其中的query是指点击之后会携带这些数据，进入小程序，但是现在可能是个人开发不能够进行朋友圈的分享，所以分享到朋友圈图标是灰色的
![[Pasted image 20251229182144.png]]

##### 6.0.2 分享给朋友
朋友点击之后，就会跳转到其中设置的页面
方法一：
![[Pasted image 20251229182442.png]]
![[Pasted image 20251229182500.png]]

方法二：
这种方式会在页面上显示一个按钮，然后可以点击进行转发,但是由于以下原因，所以无图片
![[Pasted image 20251229182641.png]]
![[Pasted image 20251229182719.png]]

### 6.1 获取头像

其中需要先设置一个默认的头像，然后下面写的这种形式，是为了可以点击图片，然后再去更改图片，但在实际的开发过程中，要是想要完全的把一个头像作为微信小程序的头像，需要把更改后的图片的值放到本地数据库中

![[Pasted image 20251229185504.png]]
![[Pasted image 20251229185514.png]]
![[Pasted image 20251229185528.png]]

### 6.2 获取用户昵称
其中的nickname是指可以选择微信昵称，但当选择微信昵称的时候，会导致，双向绑定失效，也就是说，下面的那个函数，在控制台时不会打印出东西的
![[Pasted image 20251229191538.png]]
![[Pasted image 20251229191647.png]]

```
mode：value="{{userName}}"的使用详情：
当希望用户在输入框（<input>）或选择器中输入内容时，变量 userName 的值能自动更新，而不需要手动写bindtap="函数"去setData时，可以进行使用

具体使用场景：
	A.登录或注册页面
		当你需要收集用户名、密码、手机号时，使用model:value可以少写很多重复的 onInputChange函数，让JS代码非常简洁。
	B.搜索框
		在实现实时搜索功能时，输入框里的内容需要立刻反映到data中进行接口请求，这时使用双向绑定非常方便。
	C.设置/个人资料修改
修改昵称、个人简介等字段时，直接绑定对应的data变量。

```

### 6.3 获取手机号-快捷登录

前提：
 1 手机号接口，必须是非个人开发者，并且完成了认证的小程序
 2 两种验证方式需要付费使用，每个小程序账号有1000次体验额度
##### 操作过程（前后端配合）：
	1 前端配合获取手机号，然后携带者code到后端
	2 后端（注册接口+登录接口）：后端通过code，去微信开发平台，换取真正的手机号
		-检测后端的用户表，若这个用户没有注册过，则先注册然后再签发token，登录成功
		-检测后端的用户表，若这个用户注册过，则直接签发token，登录成功
##### 6.3.1 手机号快速验证(相当于微信手机号授权登录)

![[Pasted image 20251229194654.png]]
##### 6.3.2 手机号实时验证(实时发送验证码，然后登录)
![[Pasted image 20251229194829.png]]
##### 6.3.3总结：
无论是哪一个，js中的操作都是一样的，要把得到的code，传给后端，让后端校验，然后再返回给前端，同时，再上面的按钮中open-type中的东西是固定的，前端从来都不拿真正的数据，都是去后端拿
![[Pasted image 20251229194910.png]]

### 6.4 实时客服
![[Pasted image 20251229200524.png]]
![[Pasted image 20251229200723.png]]

# 7 智慧社区项目相关(详情请见smartDemo4)
### 7.1 小程序中集成vant-app
	1 小程序上，如果纯手写样式，对css的要求比较高
	2 使用第三方ui库,可以快速构建出比较好看的样式
##### 7.1.1 集成步骤
	1 需要让小程序支持安装npm包
		-注意:需要使用专门为微信小程序提供的npm,并不是所有第三方包都支持微信小程序
	2 电脑上安装node.js
		-类似与python解释器
		-安装完成之后会有两个命令:node(执行代码的),npm(安装第三方库的)
		-可以打开cmd，输入node -v查看nodejs的版本
	3 正常使用npm安装模块,因为需要去国外下载，所以会比较慢，以下解决方法
		方法一：开代理等
		方法二：配置镜像
			安装cnpm
			npm install -g cnpm --registry=https://registry.npm.tabao.org
		本地会多出一个cnpm命令，是淘宝的镜像站，下载比npm快一点
	4 小程序根路径
		输入命令：npm init -y ：相当于初始化，会生成package.json也就是npm的配置文件，使的这个项目可以通过npm安装东西
	5 安装vant
		# 通过 npm 安装 npm i @vant/weapp -S --production
### 7.2 node介绍
	1 正常前端写的js是只能运行在浏览器中，因为浏览器中有js的解释器环境
	2 作为前端来讲，只能写前端，写不了后端，要做前后端联调，需要学习一门后端语言
	3 有大神把Chrome浏览器中的v8解释器，使用c进行了重写，使其可以安装在操作系统之上
	4 前端人员就不需要学习新的语法，可以直接使用js语法，既能写前端又能够写后端
	5 好多第三方模块，包的构建都是使用node构建的，像vue等等
	6 删除小程序app.json中的"style": "v2"
	7 在project.config.json 的settings中加入
	 "packNpmManually": true,
	"packNpmRelationList": [
	      {
	        "packageJsonPath": "./package.json",//使用当前路径下的package.json
	        "miniprogramNpmDistDir": "./"//项目的根路径是当前路径
	      }
	8 在微信开发者工具中点击工具->构建npm
### 7.3 vant使用
	 1 引入vant的组件：
		 -app.json:全局所有页面都生效
		 -index.json：只在当前页面生效
	2 复制官网代码[https://vant-ui.github.io/vant-weapp/#/home]()，放到项目中即可
### 7.4 欢迎页面(一般用于打广告)
##### 7.4.1 wxml
![[Pasted image 20251230131919.png]]
##### 7.4.2 wxss
![[Pasted image 20251230131934.png]]
##### 7.4.1 js
![[Pasted image 20251230131949.png]]

### 7.5 导入导出(相当于对一样的内容进行封装，简化和方便操作)

导入：
![[Pasted image 20260102111842.png]]

导出：导出的这个api实际上就相当于导入的那个字典里面的内容，所以可以直接使用
![[Pasted image 20260102111907.png]]